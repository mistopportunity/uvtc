<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Painful and extreme string baker</title>
</head>
<body style="background-color:black;color:white;">
    <script>const ENV_FLAGS={};</script>

    <script src="word-syllable-maps.js"></script>
    <script src="../elven-engine/constants.js"></script>

    <p style="color:white" id="word-feed"></p>
    <input type="text" id="number-input" onkeydown="nextWord(event)"></input>

    <script>
    const stringLookup = {};
    const syllableMemo = {};
    const makeSyllableMap = function(wordLength,syllables) {
        const lookup = `${wordLength},${syllables}`;
        const stored = syllableMemo[lookup];
        if(stored) {
            return stored;
        }
        const map = [];
        const distance = Math.round(wordLength / syllables);
        let i = 0;
        let remainingSyllables = syllables;
        while(i<wordLength){
            const isSyllable = i % distance === 0;
            map.push(remainingSyllables > 0 && isSyllable ? 1 : 0);
            if(isSyllable) remainingSyllables--;
            i++;
        }
        syllableMemo[lookup] = map;
        return map;
    }
    const processRawStrings = function() {
        const allWordsLookup = {};
        Object.keys(stringLookup).forEach(fullString => {

            let word = "";
            let lastCharacter = null;
            for(let i = 0;i<fullString.length;i++) {

                //This has to be compatiable (essentially identical) to the method found within applySonographToPopupFeed
                const character = fullString[i];
                const nextCharacter = fullString[i+1];

                switch(character) {
                    default:
                        if(character === "'") {
                            if(!popupControlCharacters[lastCharacter] && lastCharacter
                            && !popupControlCharacters[nextCharacter] && nextCharacter
                            ) {
                                word += character;
                            }
                        } else if(!textControlCodes[character]) {
                            word += character;
                        }
                        break;
                    case ellipsis:
                    case "-":
                    case "*":
                    case " ":
                    case ",":
                    case ".":
                    case "?":
                    case "!":
                    case " ":
                        if(word) {
                            word = word.toLowerCase();
                            if(!wordSyllableMaps[word]) {
                                allWordsLookup[word] = true;
                            }
                            word = "";
                        }
                        break;
                }

                lastCharacter = character;
            }
            if(!word){
                return;
            }
            word = word.toLowerCase();
            if(wordSyllableMaps[word]) {
                return;
            }
            allWordsLookup[word] = true;
        });
        return Object.keys(allWordsLookup);
    }

    let nextWord = () => {};

    function start() {
        let wordIndex = 0;
        const wordFeed = document.getElementById("word-feed");
        const numberInput = document.getElementById("number-input");
        const neededWords = processRawStrings();
        const maps = [];
        nextWord = function(event) {
            wordIndex++;
            const word = wordFeed.textContent;
            const syllableNumber = event.key === "q" ? word.length : Number(event.key);
            wordSyllableMaps[word] = makeSyllableMap(word.length,syllableNumber);
            wordFeed.textContent = neededWords[wordIndex];
            if(wordIndex >= neededWords.length) {
                document.body.innerHTML = `const wordSyllableMaps=${JSON.stringify(wordSyllableMaps)};`
            }
            event.preventDefault();
        }
        wordFeed.textContent = neededWords[wordIndex];
    }

    fetch("string-mdf/shadow-strings.txt").then(response=>response.text()).then(text=>{
        text.split("|").filter(word=>
            word.indexOf("_") < 0 &&
            !word.endsWith(".js") &&
            !word.startsWith("{") &&
            !word.endsWith("}") &&
            !word.startsWith("./") &&
            !word.startsWith("../") &&
            !word.startsWith(".../")
        ).forEach((item,i)=>stringLookup[item]=true);
        start();
    });
    </script>
</body>
</html>
